/*
 * Copyright (c) 2009, Windsor Solutions, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Windsor Solutions, Inc., the Environmental 
 *       Council of States (ECOS), nor the names of its contributors may be 
 *       used to endorse or promote products derived from this software 
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Windsor Solutions, Inc. "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL Windsor Solutions, Inc. or ECOS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * 
 */
package com.windsor.node.plugin.mapforcebridge;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.sql.DataSource;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.time.StopWatch;
import org.springframework.beans.factory.InitializingBean;

import com.windsor.node.common.domain.CommonContentType;
import com.windsor.node.common.domain.CommonTransactionStatusCode;
import com.windsor.node.common.domain.DataServiceRequestParameter;
import com.windsor.node.common.domain.Document;
import com.windsor.node.common.domain.NodeTransaction;
import com.windsor.node.common.domain.PaginationIndicator;
import com.windsor.node.common.domain.ProcessContentResult;
import com.windsor.node.common.domain.RequestType;
import com.windsor.node.common.domain.ServiceType;
import com.windsor.node.data.dao.PluginServiceParameterDescriptor;
import com.windsor.node.plugin.BaseWnosPlugin;
import com.windsor.node.service.helper.CompressionService;
import com.windsor.node.service.helper.IdGenerator;
import com.windsor.node.service.helper.settings.SettingServiceProvider;

/**
 * Uses database-to-xml mapping code generated by Altova MapForce.
 * 
 * <p>
 * NOTE: This class defaults to <b>not</b> publishing itself via the ENDS v2.0
 * service. To change this, simply extend the class, set publishing flags to
 * true in the constructor, and override
 * {@link #getServiceRequestParamSpecs(String)
 * getServiceRequestParamSpecs(String)}.
 * </p>
 * 
 * @since OpenNode2 v1.1.4
 */
public class MapForceBridge extends BaseWnosPlugin implements InitializingBean {

    private SettingServiceProvider settingService;
    private IdGenerator idGenerator;
    private CompressionService compressionService;
    private DataSource dataSource;

    public MapForceBridge() {

        debug("Setting internal data source list");
        getDataSources().put(ARG_DS_SOURCE, null);

        getSupportedPluginTypes().add(ServiceType.QUERY_OR_SOLICIT);
    }

    public void afterPropertiesSet() {
        super.afterPropertiesSet();

        // make sure the data sources are set
        if (!getDataSources().containsKey(ARG_DS_SOURCE)) {
            throw new RuntimeException("Source data source not set");
        }

        if (null != getDataSources().get(ARG_DS_SOURCE)) {
            dataSource = getDataSources().get(ARG_DS_SOURCE);
        }

        if (null == dataSource) {
            throw new RuntimeException("Couldn't get data source");
        }

        settingService = (SettingServiceProvider) getServiceFactory()
                .makeService(SettingServiceProvider.class);

        if (settingService == null) {
            throw new RuntimeException(
                    "Unable to obtain SettingServiceProvider");
        }

        idGenerator = (IdGenerator) getServiceFactory().makeService(
                IdGenerator.class);

        if (idGenerator == null) {
            throw new RuntimeException("Unable to obtain IdGenerator");
        }

        compressionService = (CompressionService) getServiceFactory()
                .makeService(CompressionService.class);

        if (compressionService == null) {
            throw new RuntimeException("Unable to obtain CompressionService");
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * com.windsor.node.plugin.BaseWnosPlugin#process(com.windsor.node.common
     * .domain.NodeTransaction)
     */
    @Override
    public ProcessContentResult process(NodeTransaction transaction) {

        debug("Processing transaction...");

        ProcessContentResult result = new ProcessContentResult();
        result.setSuccess(false);
        result.setStatus(CommonTransactionStatusCode.Failed);

        try {

            /* ARGUMENTS */
            result.getAuditEntries()
                    .add(makeEntry("Validating transaction..."));
            validateTransaction(transaction);

            /* parameters for the MapForce "run" method are positional */
            String[] serviceArgs = transaction.getRequest().getParameters()
                    .toValueStringArray();

            result.getAuditEntries().add(
                    makeEntry("serviceArgs: " + Arrays.toString(serviceArgs)));

            List<String> argList = new ArrayList<String>();

            for (String s : serviceArgs) {

                argList.add(s);
            }

            /*
             * base file name is the flow name - we append the guid and ".xml"
             */
            String resultFileName = makeResultFileName(transaction.getFlow()
                    .getName());

            /* prepend the path to the node's tmp dir */
            resultFileName = FilenameUtils.concat(settingService.getTempDir()
                    .getAbsolutePath(), resultFileName);

            result.getAuditEntries().add(
                    makeEntry("Setting result file name to " + resultFileName));

            /* put the output filename back into the last array position */
            argList.add(resultFileName);

            /* EXECUTE */

            result.getAuditEntries().add(
                    makeEntry("Looking for mapping-specific .jar in "
                            + getPluginSourceDir()));

            MapForceHelper mapForceHelper = new MapForceHelper();
            /* get the jar file name for this service */
            String jarFileName = mapForceHelper
                    .getJarFileName(getPluginSourceDir());

            result
                    .getAuditEntries()
                    .add(
                            makeEntry("Found "
                                    + jarFileName
                                    + ", looking for first valid mapping executor... "));

            /* get the first valid class */
            Class<?> clazz = mapForceHelper
                    .getClassFromJar(FilenameUtils.concat(getPluginSourceDir()
                            .getAbsolutePath(), jarFileName));

            result.getAuditEntries().add(
                    makeEntry("Found mapping executor " + clazz.getName()
                            + ", invoking run method..."));

            /* here we go */
            StopWatch sw = new StopWatch();
            logger.debug("Starting timer");
            sw.start();

            mapForceHelper.invokeRunMethod(clazz, dataSource.getConnection(),
                    argList.toArray());

            result.getAuditEntries().add(
                    makeEntry(sw.getTime() + " millisecs to generate file"));
            sw.stop();

            File resultingFile = new File(resultFileName);

            result.getAuditEntries().add(
                    makeEntry("Resulting file size in bytes: "
                            + resultingFile.length()));

            if (!resultingFile.exists()) {
                throw new RuntimeException("Result file not created");
            }

            /* COMPRESSION and cleanup */
            Document doc = new Document();
            result.getAuditEntries()
                    .add(makeEntry("Creating Node Document..."));

            if (transaction.getRequest().getType() != RequestType.QUERY) {

                result.getAuditEntries().add(
                        makeEntry("Compressing results..."));
                resultingFile = compressionService.zip(resultingFile);
                result.getAuditEntries().add(
                        makeEntry("Result: " + resultingFile));

                doc.setType(CommonContentType.ZIP);

            } else {
                doc.setType(CommonContentType.XML);
            }

            doc.setDocumentName(FilenameUtils.getName(resultingFile
                    .getAbsolutePath()));

            doc.setContent(FileUtils.readFileToByteArray(resultingFile));

            result.getAuditEntries().add(makeEntry("Setting result..."));

            result.setPaginatedContentIndicator(new PaginationIndicator(
                    transaction.getRequest().getPaging().getStart(),
                    transaction.getRequest().getPaging().getCount(), true));

            result.getDocuments().add(doc);

            result.setSuccess(true);
            result.setStatus(CommonTransactionStatusCode.Processed);
            result.getAuditEntries().add(makeEntry("Done: OK"));

        } catch (Exception ex) {

            error(ex);
            ex.printStackTrace();

            result.setSuccess(false);
            result.setStatus(CommonTransactionStatusCode.Failed);

            result.getAuditEntries().add(
                    makeEntry("Error while executing: "
                            + this.getClass().getName() + " Message: "
                            + ex.getMessage()));

        }

        return result;
    }

    private String makeResultFileName(String fileNameArg) {

        String newFileName = null;
        String baseName;
        String fileNameExt;

        if (StringUtils.isNotBlank(FilenameUtils.getExtension(fileNameArg))) {

            fileNameExt = FilenameUtils.getExtension(fileNameArg);
            baseName = FilenameUtils.removeExtension(fileNameArg);

        } else {

            fileNameExt = "xml";
            baseName = fileNameArg;
        }

        newFileName = baseName + "-" + idGenerator.createId() + "."
                + fileNameExt;

        return newFileName;
    }

    public SettingServiceProvider getSettingService() {
        return settingService;
    }

    public void setSettingService(SettingServiceProvider settingService) {
        this.settingService = settingService;
    }

    public IdGenerator getIdGenerator() {
        return idGenerator;
    }

    public void setIdGenerator(IdGenerator idGenerator) {
        this.idGenerator = idGenerator;
    }

    public CompressionService getCompressionService() {
        return compressionService;
    }

    public void setCompressionService(CompressionService compressionService) {
        this.compressionService = compressionService;
    }

    public DataSource getDataSource() {
        return dataSource;
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public List<DataServiceRequestParameter> getServiceRequestParamSpecs(
            String serviceName) {
        return null;
    }

    @Override
    public List<PluginServiceParameterDescriptor> getParameters()
    {
        List<PluginServiceParameterDescriptor> params = new ArrayList<PluginServiceParameterDescriptor>();
        //This one is a bit different in implementation, just add 20 generic params for the mapforce plugins to use
        for(int i = 0; i < 20; i++)
        {
            params.add(new PluginServiceParameterDescriptor("Mapforce Bridge Param " + i, PluginServiceParameterDescriptor.TYPE_STRING,
                            Boolean.FALSE, "Generic Mapforce Bridge parameter."));
        }
        return params;
    }
}
